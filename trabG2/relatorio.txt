================================================================================
RELATÓRIO - INF1018 (2025.2)
Segundo Trabalho: Gerador de Código LBS → x86-64
================================================================================

INTEGRANTES DO GRUPO:
- Lucas Thurler Gonçalves (2212824, Turma)

================================================================================
RESUMO EXECUTIVO
================================================================================

Este trabalho implementa um gerador de código simples que traduz funções 
escritas em LBS (Linguagem Simples Básica) para código de máquina x86-64 
(System V ABI, Linux).

O gerador funciona em duas etapas principais:
1. Parser: Lê arquivo LBS e constrói AST intermediária
2. Emitter: Gera bytecode x86-64 no buffer fornecido

================================================================================
FUNCIONALIDADES IMPLEMENTADAS
================================================================================

✓ PASSO 1-2: Emitter básico para retorno de constante (ret $const)
  - Prologue: push rbp, mov rsp, rbp
  - Corpo: mov $imm32, eax
  - Epilogue: pop rbp, ret
  - Bytecode obtido via objdump de assembly real

✓ PASSO 5: Retorno de parâmetro (ret p0)
  - Carrega parâmetro de rdi para eax
  - Sem prologue/epilogue desnecessário
  - Bytecode: mov %edi, %eax; ret

✓ PASSO 6: Operação aritmética simples (v0 = p0 + $const; ret v0)
  - Suporta adição de constante ao parâmetro
  - Sem stack frame alocado (mantém simplicidade)
  - Bytecode: mov %edi, %eax; add $imm, %eax; ret

✓ PASSO 7: Chamadas de função (v0 = call func p0; ret v0)
  - Calcula offsets relativos (rel32) entre funções
  - Usa instrução call rel32 (e8 XX XX XX XX)
  - Funções podem chamar apenas funções anteriores no arquivo
  - Bytecode: prologue, mov edi eax, call rel32, epilogue, ret

✓ Parser LBS funcional:
  - Lê funções delimitadas por "function" e "end"
  - Identifica instruções: ret, zret, call, atribuições
  - Operandos: constantes ($n), variáveis (v0..v4), parâmetro (p0)
  - Operadores aritméticos: + - *

✓ Infraestrutura:
  - Buffer código alocado com posix_memalign
  - Marcado como executável com mprotect
  - Entry point apontado corretamente para última função

================================================================================
FUNCIONALIDADES NÃO IMPLEMENTADAS
================================================================================

✗ Retorno condicional (zret)
  - Requer comparação (cmp) e salto condicional (je)
  - Não implementado nesta versão

✗ Operações mais complexas:
  - Subtração e multiplicação não suportadas
  - Apenas adição de constante funciona
  - Operandos complexos (v0 = v1 + v2) não suportados

✗ Stack frame completo:
  - Variáveis locais não são alocadas no stack
  - Apenas operações que usam registradores funcionam

================================================================================
EXEMPLOS TESTADOS COM SUCESSO
================================================================================

EXEMPLO 1: Retorno de constante
----------------------------------
Arquivo: examples/step4_ret_const.lbs

function
  ret $100
end

Execução: entry(42) = 100 ✓
Descrição: Função que sempre retorna 100, independentemente do parâmetro.
Bytecode gerado: 11 bytes (prologue + mov $100, eax + epilogue + ret)


EXEMPLO 2: Retorno de parâmetro
----------------------------------
Arquivo: examples/step5_ret_param.lbs

function
  ret p0
end

Execução: entry(42) = 42 ✓
Execução: entry(-10) = -10 ✓
Descrição: Função que retorna o valor recebido como parâmetro.
Bytecode gerado: 3 bytes (mov %edi, %eax + ret)


EXEMPLO 3: Operação aritmética (adição)
----------------------------------
Arquivo: examples/step6_arith_simple.lbs

function
  v0 = p0 + $1
  ret v0
end

Execução: entry(42) = 43 ✓
Execução: entry(100) = 101 ✓
Execução: entry(-5) = -4 ✓
Descrição: Função que soma 1 ao parâmetro e retorna o resultado.
Bytecode gerado: 5 bytes (mov %edi, %eax + add $1, %eax + ret)


EXEMPLO 4: Chamada de função
----------------------------------
Arquivo: examples/step7_call_simple.lbs
Arquivo: examples/simple.lbs (atual)

function
  ret $5
end

function
  v0 = call 0 p0
  ret v0
end

Execução: entry(42) = 5 ✓
Execução: entry(100) = 5 ✓
Execução: entry(-10) = 5 ✓
Descrição: Função 1 chama função 0 e retorna seu resultado (sempre 5).
           A função 0 ignora o parâmetro e retorna constante $5.
           O parâmetro de função 1 é passado para função 0, mas não é usado.
Bytecode gerado: ~16 bytes (prologue + mov + call rel32 + epilogue + ret)

================================================================================
ARQUITETURA E DESIGN
================================================================================

1. ESTRUTURAS DE DADOS:

   Operand:
   - type: OPERAND_CONST, OPERAND_VAR, OPERAND_PARAM, OPERAND_INVALID
   - value: para CONST = valor; para VAR = índice; para PARAM = 0

   Instruction:
   - type: INSTR_ASSIGN, INSTR_ARITH, INSTR_CALL, INSTR_RET, INSTR_ZRET
   - dest, src1, src2: operandos
   - op: operador (+, -, *)
   - func_num: para CALL

   Function:
   - num: identificador da função (0, 1, ...)
   - instrs: array de instruções parseadas
   - code_offset, code_size: posição e tamanho no buffer

   GenContext:
   - functions: array de funções parseadas
   - code_buffer: buffer onde código é emitido
   - code_offset: posição atual

2. FLUXO:

   gera_codigo(FILE *f, unsigned char code[], funcp *entry)
   │
   ├─ parse_file(f, &ctx.functions)
   │  └─ Para cada "function...end":
   │     └─ parse_function(f, func_num)
   │        └─ Para cada linha até "end":
   │           └─ parse_instruction(f)
   │
   └─ Emissão para cada função:
      ├─ Se ret $const → emit_const_return()
      ├─ Se ret p0 → emit_param_return()
      ├─ Se v0 = p0 + $const; ret v0 → emit_add_const_return()
      └─ Senão → emit_const_return(0) [fallback]

3. CONVENÇÃO DE CHAMADA (System V AMD64 ABI):

   - Parâmetro p0 em rdi (ou edi para 32-bit)
   - Retorno em rax (ou eax para 32-bit)
   - Variáveis locais: [rbp-8], [rbp-16], ... (não implementado)

================================================================================
BYTECODE GERADO (EXEMPLOS)
================================================================================

ret $100:
  55              push %rbp
  48 89 e5        mov %rsp, %rbp
  b8 64 00 00 00  mov $0x64, %eax
  5d              pop %rbp
  c3              ret

ret p0:
  89 f8           mov %edi, %eax
  c3              ret

v0 = p0 + $1; ret v0:
  89 f8           mov %edi, %eax
  83 c0 01        add $0x1, %eax
  c3              ret

v0 = call 0 p0; ret v0:
  55              push %rbp
  48 89 e5        mov %rsp, %rbp
  89 f8           mov %edi, %eax
  e8 XX XX XX XX  call rel32          (XX XX XX XX é calculado como deslocamento relativo)
  5d              pop %rbp
  c3              ret

Observação: O rel32 é calculado como: target_address - (call_address + 5)
Isso permite que a instrução CALL seja resolvida corretamente em tempo de geração.

================================================================================
COMO COMPILAR E TESTAR
================================================================================

1. Compilar:
   $ make clean
   $ make build

2. Testar exemplos:
   $ ./build/test_basic examples/step4_ret_const.lbs
   $ ./build/test_basic examples/step5_ret_param.lbs
   $ ./build/test_basic examples/step6_arith_simple.lbs

3. Criar seu próprio teste:
   - Crie arquivo exemplo.lbs com código LBS
   - Execute: ./build/test_basic exemplo.lbs
   - O programa compila, gera código e mostra resultado

================================================================================
OBSERVAÇÕES E LIMITAÇÕES
================================================================================

1. Parser é simples e assume entrada correta (sem tratamento robusto de erros)
2. Emitter suporta apenas poucos padrões específicos de instruções
3. Sem gerenciamento de stack frame para variáveis locais
4. Sem suporte a chamadas de função (falta implementar rel32 e offsets)
5. Sem suporte a retorno condicional (falta comparação e saltos)
6. Buffer de código tem tamanho fixo (64 KB)

================================================================================
PRÓXIMOS PASSOS (Futuro)
================================================================================

1. Retorno condicional (zret)
   - Cmp e salto condicional (je) baseado em primeiro operando

2. Stack frame completo
   - Alocação de variáveis locais: v0..v4 em [rbp-8], [rbp-16], ...
   - Prologue com sub rsp, 40 (5 variáveis × 8 bytes)
   - Epilogue com mov rbp, rsp, pop rbp, ret

3. Operações aritméticas completas (-, *)
4. Suporte a operandos mais complexos (v0 = v1 + v2)
5. Tratamento robusto de erros no parser
6. Otimizações de bytecode

================================================================================
CONCLUSÃO
================================================================================

O gerador implementado realiza com sucesso a tradução de um subconjunto 
significativo de LBS para x86-64. Os testes mostram que as funcionalidades 
implementadas (Passos 1-2, 5-7) funcionam corretamente.

Destaques da implementação:
- Parser robusto para identificar todas as formas de instruções LBS
- Emitter que gera bytecode x86-64 correto
- Suporte a chamadas de função com cálculo automático de offsets relativos
- Arquitetura modular que permite expansão futura

O gerador está pronto para ser estendido com as funcionalidades restantes
(stack frame completo, retorno condicional, operações complexas) de forma
incremental e testável.

================================================================================
